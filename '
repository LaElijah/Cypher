#ifndef SHADER_H
#define SHADER_H

#include <utility> 
#include <string>
#include <glm/ext/matrix_transform.hpp>
#include <math.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <GLFW/glfw3.h>
#include <fstream>
#include <sstream>
#include <set>
#include <iostream>
#include "FileReader.h"
#include <string_view>
#include <unordered_map>
#include <map>


namespace Graphics {
    size_t GetPrimitiveBaseType(unsigned int type)
    {
	switch (type)
	{
	    case GL_FLOAT:
	    case GL_FLOAT_VEC2:  
	    case GL_FLOAT_VEC3: 
	    case GL_FLOAT_VEC4: 
	    case GL_FLOAT_MAT2: 
	    case GL_FLOAT_MAT3:
	    case GL_FLOAT_MAT4:
	    case GL_FLOAT_MAT2x3:
	    case GL_FLOAT_MAT2x4: 
	    case GL_FLOAT_MAT3x2: 
	    case GL_FLOAT_MAT3x4:  
	    case GL_FLOAT_MAT4x2: 
	    case GL_FLOAT_MAT4x3:
                return GL_FLOAT;

	    case GL_INT:
	    case GL_INT_VEC2:
	    case GL_INT_VEC3: 
	    case GL_INT_VEC4:
                return GL_INT; 

	    case GL_UNSIGNED_INT: 
	    case GL_UNSIGNED_INT_VEC2: 
	    case GL_UNSIGNED_INT_VEC3: 
	    case GL_UNSIGNED_INT_VEC4: 
		return GL_UNSIGNED_INT;

/* NOT YET SUPPORTED UNTIL GL VERSION > 4.1
	    case GL_DOUBLE:
            case GL_DOUBLE_VEC2: 
	    case GL_DOUBLE_VEC3:  
	    case GL_DOUBLE_VEC4:  
	    case GL_DOUBLE_MAT2:  
	    case GL_DOUBLE_MAT3:
	    case GL_DOUBLE_MAT4:
	    case GL_DOUBLE_MAT2x3:
	    case GL_DOUBLE_MAT2x4:
	    case GL_DOUBLE_MAT3x2:
	    case GL_DOUBLE_MAT3x4:
	    case GL_DOUBLE_MAT4x2:
	    case GL_DOUBLE_MAT4x3:
		return GL_DOUBLE;
*/	
            default:
                return 0; 
	}
    }


 
    size_t GetPrimitiveSize(unsigned int type)
    {
        switch (type) 
	{
            case GL_FLOAT:                return sizeof(float);
            case GL_FLOAT_VEC2:           return sizeof(float) * 2;
            case GL_FLOAT_VEC3:           return sizeof(float) * 3;
            case GL_FLOAT_VEC4:           return sizeof(float) * 4;
            case GL_FLOAT_MAT2:           return sizeof(float) * 2 * 2;
            case GL_FLOAT_MAT3:           return sizeof(float) * 3 * 3;
            case GL_FLOAT_MAT4:           return sizeof(float) * 4 * 4;
            case GL_FLOAT_MAT2x3:         return sizeof(float) * 2 * 3;
            case GL_FLOAT_MAT2x4:         return sizeof(float) * 2 * 4;
            case GL_FLOAT_MAT3x2:         return sizeof(float) * 3 * 2;
            case GL_FLOAT_MAT3x4:         return sizeof(float) * 3 * 4;
            case GL_FLOAT_MAT4x2:         return sizeof(float) * 4 * 2;
            case GL_FLOAT_MAT4x3:         return sizeof(float) * 4 * 3;
            case GL_INT:                  return sizeof(int);
            case GL_INT_VEC2:             return sizeof(int) * 2;
            case GL_INT_VEC3:             return sizeof(int) * 3;
            case GL_INT_VEC4:             return sizeof(int) * 4;
            case GL_UNSIGNED_INT:         return sizeof(unsigned int);
            case GL_UNSIGNED_INT_VEC2:    return sizeof(unsigned int) * 2;
            case GL_UNSIGNED_INT_VEC3:    return sizeof(unsigned int) * 3;
            case GL_UNSIGNED_INT_VEC4:    return sizeof(unsigned int) * 4;

/* NOT YET SUPPORTED UNTIL GL VERSION > 4.1
            case GL_DOUBLE:               return sizeof(double);
            case GL_DOUBLE_VEC2:          return sizeof(double) * 2;
            case GL_DOUBLE_VEC3:          return sizeof(double) * 3;
            case GL_DOUBLE_VEC4:          return sizeof(double) * 4;
            case GL_DOUBLE_MAT2:          return sizeof(double) * 2 * 2;
            case GL_DOUBLE_MAT3:          return sizeof(double) * 3 * 3;
            case GL_DOUBLE_MAT4:          return sizeof(double) * 4 * 4;
            case GL_DOUBLE_MAT2x3:        return sizeof(double) * 2 * 3;
            case GL_DOUBLE_MAT2x4:        return sizeof(double) * 2 * 4;
            case GL_DOUBLE_MAT3x2:        return sizeof(double) * 3 * 2;
            case GL_DOUBLE_MAT3x4:        return sizeof(double) * 3 * 4;
            case GL_DOUBLE_MAT4x2:        return sizeof(double) * 4 * 2;
            case GL_DOUBLE_MAT4x3:        return sizeof(double) * 4 * 3;
*/

            default:                      return 0; // Unknown type
        }	
    }

    
    enum SHADER_FILE_TYPE
    {
        VERTEX,
        FRAGMENT
    };
    
    
    struct ShaderFileData 
    {
        SHADER_FILE_TYPE type;
        std::string data; 
        std::string path;
    };
    
    struct ShaderInfo
    {
	public: 
            std::vector<ShaderFileData> shaders;
	    std::string name;
    
            ShaderInfo(
	        std::string shaderName,
                std::string vertexShaderPath, 
    	        std::string fragmentShaderPath)
            {
                name = shaderName; 
                loadData(vertexShaderPath.c_str(), fragmentShaderPath.c_str());   
	    };
              
            ShaderInfo(
                const char* shaderName,
                const char* vertexShaderPath, 
    	        const char* fragmentShaderPath)
            {
                name = std::string(shaderName); 
	        loadData(vertexShaderPath, fragmentShaderPath);
            };

        private:
            template <typename...Args>
	    void loadData(Args... args)
	    {
	        constexpr int numArgs = sizeof...(args);
		//static_assert(numArgs <= maxShaderTypes, "Too many shader files for one shader program");

		std::vector<std::string> shaderFiles = {args...};
	        validateShaderSupport(shaderFiles); 

                for (std::string& file : shaderFiles)
		{
		    ShaderFileData data;
	            std::fstream shaderFile;	
                     
                    shaderFile.exceptions(
    	    	    	std::ifstream::failbit 
    	    	    	| std::ifstream::badbit);
    
                    try 
                    {
                        shaderFile.open(file);
		 	std::stringstream shaderSource;
    	                shaderSource << shaderFile.rdbuf();
		   	shaderFile.close();
		        	
			data.type = extensionEnums.find(
				Graphics::FileReader::splitFileExtension(
				Graphics::FileReader::getNameFromDirectory(file))
			        .second)->second;

                        data.data = shaderSource.str();
    	                data.path = std::string(file);
                    
		    	shaders.push_back(data);			
    	            }
                    catch (std::ifstream::failure e)
                    {
                        std::cout << "ERROR::SHADER::FILE_NOT_SUCCESSFULLY_READ\n" << e.what() << "\n" << std::endl;
                    }
		}
	    }		

	    static const std::set<std::string_view> supportedExtensions;
	    static const std::unordered_map<std::string, Graphics::SHADER_FILE_TYPE> extensionEnums;
            
	    // TODO: Get compile time loading for this from supported extensions
	    static const int maxShaderTypes = 2;

            void validateShaderSupport(const std::vector<std::string>& files);
    };

 
    template <typename T>
    class Shader
    {
        public:

            Shader(Graphics::ShaderInfo& info) : info(info)
	    {
	         
	    }
	    
	    void use()
	    {
	        static_cast<T*>(this)->useImpl(); 
	    }	   

	    void setUniform(std::string name, bool value)
	    {
	    
	        static_cast<T*>(this)->useImpl(name, value); 
	    } 

	    void setUniform(std::string name, int value)
	    {
	    
	        static_cast<T*>(this)->useImpl(name, value); 
	    } 

	    void setUniform(std::string name, float value)
	    {
	    
	        static_cast<T*>(this)->useImpl(name, value); 
	    }

            void setUniform(
			    std::string name, 
			    float value1, 
			    float value2, 
			    float value3)
	    {
	    
	        static_cast<T*>(this)->setUniformImpl(
				name, 
				value1, 
				value2, 
				value3); 
	    }

	    void setUniform(std::string name, glm::mat4 value)
	    { 
	        static_cast<T*>(this)->setUniformImpl(name, value); 
	    } 


        protected:
	    Graphics::ShaderInfo& info; 
    };


    struct OpenGLVertexAttribute
    {
        std::string name;
        int size;
        unsigned int type;	
	unsigned int component;
        unsigned int offset;
	unsigned int normalize;
    };

    struct OpenGLUniform
    {
        std::string name;
        int size;
        unsigned int type;	
    };
    

    class OpenGLShader : public Shader<OpenGLShader>
    {
	public: 
            OpenGLShader(Graphics::ShaderInfo& info);
	    void useImpl();
   	    void setUniformImpl(std::string name, bool value);
	    void setUniformImpl(std::string name, int value);
	    void setUniformImpl(std::string name, float value); 
	    void setUniformImpl(
			    std::string name, 
			    float value1, 
			    float value2, 
			    float value3);
	    
	    void setUniformImpl(std::string name, glm::mat4 value);

	    std::pair<size_t, std::vector<Graphics::OpenGLVertexAttribute>> getFormat(); 

        private:
	    unsigned int ID;
	    size_t formatKey;

	    unsigned int compileShader(Graphics::ShaderFileData& shader);
            void linkShader(unsigned int shader);
	    void storeFormat(size_t& key);

	    std::vector<Graphics::OpenGLVertexAttribute> m_Attributes;
	    std::vector<Graphics::OpenGLUniform> m_Uniforms;


	    static std::map<size_t, std::vector<Graphics::OpenGLVertexAttribute>> m_Formats;
    };


}






#endif
