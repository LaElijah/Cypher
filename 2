
#include <glad/glad.h>
#include "RenderAPI.h"

#include <iostream>




//OPENGL API

void Graphics::OpenGLRenderAPI::loadTexturesImpl(std::vector<Graphics::Texture>& textures)
{
    unsigned int diffuseN = 1;
    unsigned int specularN = 1;
    unsigned int ambientN = 1;
    unsigned int lightmapN = 1;
    unsigned int reflectionN = 1;
   
    for (unsigned int i = 0; i < textures.size(); i++)
    {
        glActiveTexture(GL_TEXTURE0 + i);

          
        std::string number;
        std::string name = textures[i].type;



        if(name == "texture_diffuse")
          number = std::to_string(diffuseN++);
        
	else if (name == "texture_specular")
          number = std::to_string(specularN++);

	else if (name == "texture_ambient")
          number = std::to_string(ambientN++);

	else if (name == "texture_lightmap")
          number = std::to_string(lightmapN++);

	else if (name == "texture_reflection")
          number = std::to_string(reflectionN++);


        //shader.setInt(("material." + name + number).c_str(), i);
        glBindTexture(GL_TEXTURE_2D, textures[i].id);

    }

    glActiveTexture(GL_TEXTURE0);

}

void Graphics::OpenGLRenderAPI::drawElementsImpl(int count, bool unbind)
{
    glDrawElements(GL_TRIANGLES, count, GL_UNSIGNED_INT, 0);

    if (unbind)
        glBindVertexArray(0);
}

void Graphics::OpenGLRenderAPI::clearImpl()
{
    // Move implememntation to api 
    glClearColor(0, 0.01f, 0.01f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

///////////////////////////////
// PRIVATE ////////////////////
///////////////////////////////


// GOALS:
//
// NEEDS A TRANSLATE FUNCTION TO GET TO AND FROM 
// AN INT (OR WHATEVER DATA TYPE) BACK TO FORMAT TYPES
void Graphics::OpenGLRenderAPI::formatBuffer(Graphics::RenderConfig& config, Graphics::VertexFormat format)
{
    // Set up vao after binding
    //


    std::vector<Graphics::VertexAttribute> attributes = Graphics::GetFormatAttributes(format);

    for (Graphics::VertexAttribute attribute : attributes)
    {
        switch (attribute)
	{
	    case Graphics::FLOAT: 
	    {
	    
	    }	    
	}	 
    }
}

// Move implememntation to api 
// Should be indexed by shader name 
Graphics::RenderConfig& Graphics::OpenGLRenderAPI::generateRenderConfig(Graphics::VertexFormat format)
{
    if (RenderConfigs.count(format))
	return RenderConfigs[format];

    Graphics::RenderConfig config;
    
    glGenVertexArrays(1, &config.VAO); 
    glBindVertexArray(config.VAO);

    glGenBuffers(1, &config.VBO);
    glBindBuffer(GL_ARRAY_BUFFER, config.VBO);

    glGenBuffers(1, &config.EBO);  
    formatVAO(config, format);


    RenderConfigs[format] = std::move(config);

    return getRenderConfig(format);
}

    /*
    // FORMAT VAO GENERATOR AND STORE
    switch (vaoType)
        case DEBUG:
            {
                glEnableVertexAttribArray(0);
                glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Graphics::Vertex), (void*)0);


                glEnableVertexAttribArray(1);
                glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Graphics::Vertex), (void*)offsetof(Graphics::Vertex, Graphics::Vertex::Normal));


                glEnableVertexAttribArray(2);
                glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Graphics::Vertex, Graphics::Vertex::TexCoords));
            }

*/	 
Graphics::RenderResource& Graphics::OpenGLRenderAPI::getRenderConfig(Graphics::VertexFormat format)
{
    // Was the vao found in our vector?
    if (RenderConfigs.count(format)) 
    {
        // Return the found render entitiy
	return RenderConfig[format];
    }
    else 
    {
	std::cout << "GENERATING NEW RENDER CONFIGURATION:"  << std::endl;
        return generateRenderConfig(format);
    }
}



void Graphics::OpenGLRenderAPI::loadDataImpl(
	                    std::vector<Graphics::Vertex>& vertices, 
			    std::vector<unsigned int>& indices, 
			    Graphics::VertexFormat format)
{
    // Change this to OPENGL specific namespace
    Graphics::RenderConfig config = getRenderConfig(format);

    if (CURRENT_FORMAT != config.format)
    {
        glBindVertexArray(config.VAO);
        glBindBuffer(GL_ARRAY_BUFFER, config.VBO);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, config.EBO);
    }
    
    glBufferData(GL_ARRAY_BUFFER, sizeof(Graphics::Vertex) * vertices.size(), &vertices[0], GL_STATIC_DRAW);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(unsigned int) * indices.size(), &indices[0], GL_STATIC_DRAW);
}
